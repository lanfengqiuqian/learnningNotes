<!--
 * @Date: 2020-09-07 21:55:29
 * @LastEditors: Lq
 * @LastEditTime: 2022-06-30 12:25:08
 * @FilePath: \learnningNotes\regular-expression\index.md
-->

### 介绍（Regular Expression）

1. 是一种文本模式，包括普通字符和元字符（特殊字符）
2. 使用单个字符串来描述，匹配一系列满足某个语法规则的字符串
3. 将匹配的子串替换或取出符合条件的子串

作用：

1. 文本搜索：从给定的字符串中找出满足条件的子串
2. 文本替换：将字符串中的某些子串替换为需要的文本
3. 校验规则：判断给定的自付出是否满足某种规则

### 常用方法

#### 字符串方法

1. search()：找出首个满足条件的子串的起始位置

   > let str = "hello world";  
   > let pattern = /w/g;  
   > let index = str.search(pattern); // 6

2. replace()：替换满足条件的子串，有`g`替换所有，没有`g`替换第一个

   > let str = "hello world";  
   > let pattern = /w/g;  
   > let newStr = str.search(pattern, 'aaa'); // hello aaaworld

3. match()：找出字符串中满足条件的子串，返回一个数组，如果有`g`找出所有，没有`g`找出第一个

   > ("The best things in life are free!").match(/e/g)  
   > ["e", "e", "e", "e", "e", "e"]
   >
   > ("The best things in life are free!").match(/e/)  
   > ["e", index: 2, input: "The best things in life are free!", groups: undefined]

#### 正则表达式方法

1. test()：检测一个字符串中是否有子串满足某种规则

   > let str = "hello world";  
   > let pattern = /w/g;  
   > let isExist = pattern.test(str); // true

2. exec()：检索首个到的子串（数组），如果没有返回 null

   > let str = "hello world";  
   > let pattern = /l/g;  
   > let arr = pattern.exec(str); // ["l", index: 2, input: "hello world", groups: undefined]

### 示例

> ^[0-9]+abc$ // 匹配以数字开头，并以 abc 结尾的字符串

- `^`为匹配字符串开始位置
- `[0-9]+`匹配多个数字，`[0-9]`匹配单个数字，`+`匹配一个或多个
- `abc`匹配包含`abc`的
- `$`表示匹配字符串的结束位置

### 普通字符

概念：所有大写和小写字母、所有数字、所有标点符号、一些其他符号。

| 字符   | 描述                                                             | 示例                                                                           |
| ------ | ---------------------------------------------------------------- | ------------------------------------------------------------------------------ |
| [ABC]] | 匹配[]内的某一个满足条件的字符                                   | `/[abc]/g`匹配 a 或 b 或 c                                                     |
| [^ABC] | 匹配除了[]内的字符                                               | `/[^abc]/g`匹配除了 a、b、c 之外的字符                                         |
| [A-Z]  | 匹配某一个区间内的字符                                           | `/[A-Z]/g`匹配所有大写字母，`/[a-z]/g`匹配所有小写字母，`/[0-9]/g`匹配所有数字 |
| .      | 匹配除了换行符（\n、\r）之外的任意单个字符，相当于[^\n\r]        | `/./g`                                                                         |
| [\s\S] | 匹配所有，\s 是匹配所有空白符，\S 是匹配所有非空白符（包括换行） | `/[\s\S]/g`                                                                    |
| \w     | 匹配字母，数字，下划线，等价于[A-Za-z0-9_]                       | `/\w/g`                                                                        |
| \W     | 匹配非字母、数字、下划线，等价于[^A-Za-z0-9]                     |
| \d     | 匹配一个数字字符，等价于[0-9]                                    |
| \D     | 匹配一个非数字字符，等价于[^0-9]                                 |
| \num   | 匹配 num，其中，num 是一个正整数。对所获取的配的引用             | 如`/(.)\1/`匹配连续的相同字符                                                  |
| \un    | 匹配 n，其中 n 是一个用 4 个 16 进制数字表示的 Unicode 字符      | 如`\u00A9`匹配的是版权符号(?)                                                  |

### 非打印字符

| 字符 | 描述                                                                              | 示例                            |
| ---- | --------------------------------------------------------------------------------- | ------------------------------- |
| \cx  | 其中 x 表示指定的控制字符，必须由大写字母或小写字母组成，否则将 c 视为一个 c 字符 | \cM 匹配一个 Control-M 或回车符 |
| \f   | 匹配一个换页符                                                                    | 等价于\x0c 和\cL                |
| \n   | 匹配一个换行符                                                                    | 等价于\x0a 和\cJ                |
| \r   | 匹配一个回车符                                                                    | 等价于\x0d 和\cM                |
| \s   | 匹配任何空白符，包括空格、制表符、换页符等，Unicode 正则表达式会匹配全角空格符    | 等价于[\f\n\r\t\v]              |
| \S   | 匹配任何非空白字符                                                                | 等价于[^\f\n\r\t\v]             |
| \t   | 匹配一个制表符                                                                    | 等价于\x09 和\cl                |
| \v   | 匹配一个垂直制表符                                                                | 等价于\x0b 和\cK                |

### 特殊字符

概念：有一些特殊含义的字符，如果要匹配这些字符，使用`\`进行转义

| 特殊字符 | 描述                                                                                                                             | 转义匹配   |
| -------- | -------------------------------------------------------------------------------------------------------------------------------- | ---------- |
| ^        | 不在方括号中使用时，匹配输入字符串的开始位置。在方括号中使用时，需要放在方括号内开头，表示匹配除了方括号中之外的字符，如`[^abc]` | `\^`       |
| $        | 匹配输入字符串的结尾位置，如果设置了 RegExp 对象的 Multline 属性，也匹配`\n`和`\r`                                               | `\$`       |
| ()       | 标记一个子表达式的开始和结束位置，子表达式可以获取以供以后使用                                                                   | `\(`、`\)` |
| \*       | 匹配前面的子表达式 0 次或多次                                                                                                    | `\*`       |
| +        | 匹配前面的子表达式一次或多次                                                                                                     | `\+`       |
| ?        | 匹配前面的子表达式 0 次或 1 次，或者是指定一个非贪婪限定符                                                                       | `\?`       |
| .        | 匹配出换行符之外的任何单个字符                                                                                                   | `\.`       |
| []       | 匹配一个中括号开始或者结束位置                                                                                                   | `\[`、`\]` |
| \\       | 将下一个字符标记为特殊字符、愿意字符、向后引用、八进制转义符                                                                     | `\\`       |
| {}       | 标记限定符表达式的开始                                                                                                           | `\{`、`\}` |
| \|       | 指明两项中的一个选择                                                                                                             | `\|`       |

### 限定符

概念：用来指定正则表达式中的一个给定组件必须要出现多少次

| 字符   | 描述        | 示例        |
| ------ | ----------- | ----------- |
| \*     | 0 次或多次  | 等价于{0,}  |
| +      | 一次或多次  | 等价于{1,}  |
| ?      | 0 次或 1 次 | 等价于{0,1} |
| {n}    | 确定的 n 次 |
| {n,}   | 至少 n 次   |
| {n,,m} | n 到 m 次   |

#### 贪婪匹配和非贪婪匹配

概念：`*`和`+`限定符进行匹配的时候都是贪婪的，会尽可能多的匹配字符，使用`?`对于限定符进行限制为非贪婪匹配

> 给定字符串`<h1>RUNOOB-菜鸟教程</h1>`  
> 贪婪匹配规则：`/<.*>/g`  
> 结果`<h1>RUNOOB-菜鸟教程</h1>`，即匹配了整个字符串
>
> 非贪婪匹配规则：`/<.*?>/g`  
> 结果：`<h1>`，即只匹配 h1 开始标签

### 定位符

概念：描述字符串或者单词的边界，能够创建固定到行尾或行首的表达式，或者是在一个单词开始或者结尾的表达式

| 字符 | 描述                                                                                  |
| ---- | ------------------------------------------------------------------------------------- |
| ^    | 字符串开始位置，如果设置了 RegExp 对象的 Multiline 属性，还会与\n 和\r 之后的位置匹配 |
| $    | 字符串结束位置，如果设置了 RegExp 对象的 Multiline 属性，还会与\n 和\r 之后的位置匹配 |
| \b   | 匹配一个单词的边界，即肌肤和空格之间的位置                                            |
| \B   | 非单词边界匹配                                                                        |

注意：不能将限定符和定位符一起使用

对于`^`和`$`的理解：

> /^hello/g  
> `hello`, I am zhangsan, nice to meet you! hello, hahaha!  
> 找到开头中的 hello
>
> /ha!$/g  
> hello, I am zhangsan, nice to meet you! hello, haha`ha!`  
> 找到结尾处的 ha!
>
> /^hello(.\*)ha!/g  
> `hello, I am zhangsan, nice to meet you! hello, hahaha!`  
> 找到开头是 hello 并且结尾是 ha!

一般来说，同时使用`^`和`$`的话用于校验整个字符串是否满足某种条件，如果是判断字符串是否包含满足某种条件的子串的话不会使用`^`和`$`

比如说，密码是 123，当输入的是 1234 的时候我们肯定不希望其通过，所以需要使用`^`和`$`，如果不用的话值为 true

### 修饰符（标记）

概念：用于指定额外的匹配策略

| 字符 | 含义                        | 描述                                                               |
| ---- | --------------------------- | ------------------------------------------------------------------ |
| i    | ignore，不区分大小写        | A 和 a 没有区别                                                    |
| g    | global，全局匹配            | 查找所有匹配项，如果不加说明匹配第一个                             |
| m    | multiline，多行匹配         | 使边界符`^`和`$`匹配`每一行`（而不是整个字符串）的开头和结尾       |
| s    | 让特殊字符`.`能够匹配换行符 | 正常情况下`.`是匹配除换行符之外的任意字符，加上`s`后能够包含换行符 |

### 先行断言和后行断言

零宽：只匹配某些位置，在匹配的过程中，不占用字符

1. `(?=pattern)`：零宽正向先行断言

   代表字符串中的一个位置，紧接该位置之后的字符串序列能够匹配 pattern

   > /re(?=gular)/g  
   > a `re`gular expression  
   > 匹配到了 regular 中的 re，而不是 expression 中的 re
   >
   > /re(?=gular)./g  
   > a `reg`ular expression  
   > 匹配到了 regular 中的 reg

2. `(?!pattern)`：零宽负向先行断言

   代表字符串中的一个位置，紧接该位置之后的字符串序列不能够匹配 pattern

   > /re(?!g)  
   > a regular exp`re`ssion  
   > 匹配到了 expression 中的 re

3. `(?<=pattern)`：零宽正向后行断言

   代表字符串中的一个位置，紧接该位置之前的字符串序列能够匹配 pattern

   > /(?<=\w)re/g  
   > regex rep`re`sents regular exp`re`ssion  
   > 匹配到了不是单词开头的 re，而是单词中的 re

4. `(?<!pattern)`：零宽负向后行断言

   代表字符串中的一个位置，紧接该位置之前 的字符串序列不能够匹配 pattern

   > /(?<!\w)re/g  
   > `re`gex `re`presents `re`gular expression  
   > 匹配到了单词开头的 re，而不是是单词中的 re

### 运算符优先级

1. `\`：转义符
2. `()`,`(?:)`,`(?=)`,`[]`：圆括号和方括号
3. `*`,`+`,`?`,`{n}`,`{n,}`,`{n,m}`：限定符
4. `^`,`$`,`\任何元字符`,`任何字符`：定位点和序列（即位置和顺序）
5. `|`：替换，“或”操作

### Unicode 编码字符集分类

| 符号 | 意义                           |
| ---- | ------------------------------ |
| L    | 字母                           |
| P    | 标点符号（注意不包括$和￥）    |
| M    | 标记符号（一般不会单独出现）   |
| Z    | 分隔符（比如空格、换行）       |
| S    | 符号（如数学符号，货币符号）   |
| N    | 数字（如阿拉伯数字、罗马数字） |
| C    | 其他字符                       |

在 js 中的使用

> let reg = /\p{L}/u; // 匹配所有字母  
> let reg = /\P{L}/u; // 匹配所有非字母  
> let reg = /\p{P}/u; // 匹配所有标点符号  
> let reg = /\P{P}/u; // 匹配所有非标点符号

注意： 1. 如果`\p`的`p`是小写是匹配符合条件的，如果是大写是匹配不符合条件的。  
 2. `/u`不能少，要不然会失效。

其他详细可参考这篇[博客](https://www.cnblogs.com/qixuejia/p/4211428.html)

### 常用正则匹配

1. 匹配中文

   > /[\u4e00-\u9fa5]/

2. 匹配标点符号（这里使用到的是 unicode 的分类）

   > /\p{P}/u

   但是这里进钱的符号没有匹配上需要手动加上去

   > /[\p{P}]|[$]|[￥]/u

3. 匹配姓名（包含少数民族）

   > /(^[\u4e00-\u9fa5]{1}[\u4e00-\u9fa5\.·。]{0,18}[\u4e00-\u9fa5]{1}$)|(^[a-zA-Z]{1}[a-zA-Z\s]{0,18}[a-zA-Z]{1}$)/

4. 匹配括号

   > encode.match(/\([^\)]+\)/g)

5. 匹配邮箱

   > /[\w!#$%&'*+/=?^_`{|}~-]+(?:\.[\w!#$%&'*+/=?^_`{|}~-]+)_@(?:[\w](?:[\w-]_[\w])?\.)+[\w](?:[\w-]*[\w])?/

   匹配密码，字母数字特殊字符

   > /^(?=._[A-Za-z])(?=._\d)(?=._[`~!@#$%^&_()_+<>?:"{},.\/\\;'[\]])[A-Za-z\d`~!@#$%^&\*()_+<>?:"{},.\/\\;'[\]]{8,}$/

6. 空格分隔手机号正则

   > '88888888888'.replace(/^(.{3})(.\*)(.{4})$/, '$1 $2 $3')
