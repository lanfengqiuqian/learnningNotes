<!--
 * @Date: 2022-07-07 12:56:34
 * @LastEditors: Lq
 * @LastEditTime: 2022-08-24 09:26:35
 * @FilePath: \learnningNotes\面试题\前端基础.md
-->
[TOC]

## HTTP/HTML/浏览器

### http和https

https的ssl加密是在传输层实现的

1. 基本概念

    1. http

        1. 超文本传输协议，是互联网上应用最为广泛的一种网络协议
        2. 是客户端和服务端请求和应答的标准（TCP）
        3. 用于从WWW服务器传输超文本到本地浏览器的传输协议
        4. 可以使浏览器更加高效，使网络传输减少

    2. https

        1. 是以安全为目标的HTTP通道，简单说是HTTP的安全版
        2. 在HTTP下加入了SSL层
        3. 主要作用是：建立一个信息安全通道，来确保数据的传输，确保网站的真实性


2. 区别

    1. http的数据是未加密的，也就是明文的，网景公司设置了SSL协议来对http协议传输的数据进行加密处理，比http协议的安全性更高
    2. https协议需要ca证书，费用较高
    3. 使用不同的链接方式，端口也不同，一般来说，http的端口为80，https的端口为443
    4. http的连接简单，是无状态的，https是由ssl+http协议构建的可进行加密传输、身份认证的协议

3. https协议的工作原理

    1. 客户端使用https的url访问服务器，要求web服务器建立ssl连接
    2. web服务器接收到客户端的请求之后，会将网站的证书（包含公钥）返回给客户端
    3. 客户端和服务器开始协商建立SSL连接的安全等级，也就是加密等级
    4. 客户端建立会话密钥，然后通过网站的公钥来加密会话密钥，并传送给网站
    5. 服务器通过自己的密钥解密出会话密钥
    6. 服务器通过会话密钥加密和客户端之间的通信

4. https协议的优点

    1. 能够确保数据可以发送到正确的客户机和服务器
    2. 可以防止数据在传输过程中不会被窃取、改变，能够确保数据的完整性
    3. 是现行架构下最安全的解决方案，大幅度增加了中间人攻击的成本
    4. https加密的网站在google搜索结果中排名会比http更高


5. https协议的缺点

    1. 握手阶段比较费时，使页面加载时间延长50%，增加了10-20%的耗电
    2. 缓存不如http高效，会增加数据开销
    3. ssl证书收费，功能越强大的证书费用更高
    4. ssl证书需要绑定ip，不能在同一个ip上绑定多个域名，因为ipv4资源支持不了这种消耗


### tcp三次握手

1. 客户端向服务器发起建立连接的请求
2. 服务端告诉客户端，我同意你的连接请求，同时向客户端发起建立连接的请求
3. 客户端告诉服务端，我同意你的连接请求


### TCP和UDP

1. 概念

    TCP：传输控制协议，是面向连接的、可靠的、基于字节流的传输层通信协议

        将大块数据切割为报文段为单位的数据包进行管理

    UDP：用户数据报协议，为应用程序提供了一种无需建立连接就可以发送封装的IP数据报的方法

        在很多实时性要求高的地方有用

2. 区别

   1. TCP是面向连接的，UDP是无连接的，即发送数据前不需要先建立连接
   2. TCP提供可靠的服务，通过TCP连接传送的数据，无差错、不丢失、不重复，且按序到达，适合做大数据量的交换；UDP不能保证可靠交付
   3. TCP面向字节流，UDP面向报文，并且网络出现拥塞不会使得发送速率降低，比如实时的应用如电话和视频会议等
   4. TCP只能是1对1的，UDP支持1对1、1对多
   5. TCP首部较大，为20字节，UDP只有8字节
   6. TCP是面向连接的可靠性传输，UDP是不可靠的


### WebSocket的实现和应用

1. 概念

    1. 是HTML5中的协议，本质上是基于TCP的协议
    2. 支持持久连接
    3. 给web端提供了和服务端之间的长连接
    4. 使得在建立连接的任何时候服务端都可以主动通知web端

2. websocket和http的关系

    1. 相同点

        1. 都是基于tcp的、可靠性的传输协议
        2. 都是应用层协议

    2. 不同点

        1. websocket是双向通信协议，模拟socket协议，可以双向发送或者接收信息，而http是单向的
        2. websocket是需要浏览器和服务器握手进行建立连接的，而http是浏览器向服务器的连接，服务器预先并不知道这个连接

3. 过程

    1. 客户端发起http请求，经过3次握手，建立TCP链接
    2. http请求里面存放websocket支持的版本号的等信息
    3. 服务器接收到客户端的握手请求后，同样采用http协议回馈数据
    4. 客户端收到连接成功的消息后，开始接触TCP传输系信息进行双全工通信

4. websocket解决的问题

    1. http是一种无状态协议，每当一次会话完成后，服务端都不知道下一次的客户端是谁，需要每次知道对方是谁，才会进行相应的响应，因此，本身对于实时通讯就是一种极大的障碍
    2. http协议采用一次请求，一次响应，每次请求和响应都携带有大量的header头，对于实时通讯来说，解析请求头也是需要一定的时间，因此，效率也更低下
    3. 最重要的是，需要客户端主动发，服务端被动发，不能实现主动发送


### HTTP请求之HEADER

1. 定义

    HEAD方法和GET方法相同，只不过服务器响应时不会返回消息体。一个HEAD请求的响应中，HTTP头中包含的元信息应该和一个GET请求的响应消息相同。这种方法用来获取请求中隐含的元信息，而不用传输实体本身，所以常用来测试超链接的有效性、可用性和最近的修改

2. HEAD请求尝尝被忽略，但是可以提供很多有用的信息，特别是在有限的速度和带宽下，特点如下

    1. 只请求资源的首部
    2. 检查超链接的有效性
    3. 检查网页是否被修改
    4. 多用于自动搜索机器人获取网页的标志信息，获取rss种子信息，或者传递安全认证信息等


### 几个很实用的BOM属性对象方法

1. 什么是BOM：BOM是浏览器对象

2. 常用属性

    1. location对象

        1. location.href：返回或者设置当前文档的URL
        2. location.search：返回URL中查询字符串部分
        3. location.hash：返回URL`#`后面的内容，如果没有返回空
        4. location.host：返回URL中的域名部分，如www.baidu.com
        5. location.hostname：返回URL的主域名的部分，如baidu.com
        6. location.pathname：返回URL域名后的部分，如https://www.baidu.com/demo1/返回/demo1/
        7. location.port：返回URL中的端口部分
        8. location.protocol：返回URL中的协议部分，如https://www.baidu.com返回//前面的https
        9. location.assign：设置当前文档的URL
        10. location.replace()：设置当前文档的URL，并且在history对象的地址列表中移除这个URL
        11. location.reload()：重载当前页面

    2. history对象

        1. history.go()：前进或者后退指定的页面数，如果参数是0的话则刷新当前页面
        2. history.back()：后退一页
        3. history.forward()：前进一页

    3. navigator对象

        1. navigator.userAgent：返回用户代理头的字符串表示（就是包括浏览器版本信息等的字符串）
        2. navigator.cookieEnabled：返回浏览器是否支持（启用）cookie


### 说一下HTML5的drag api

1. dragstart：事件主体是被拖放元素，在开始拖放元素时触发
2. drag：事件主体是被拖放元素，在正在拖放元素时触发
3. dragenter：事件主体是目标元素，在元素被拖进目标元素时触发
4. dragover：事件主体是目标元素，在元素在目标元素中移动时触发
5. dragleave：事件主体是目标元素，在元素移出目标元素时触发
6. drop：事件主体是目标元素，在目标元素完全接受元素时触发
7. dragend：事件主体是被拖放元素，在整个拖放操作结束时触发


### 说一下http2.0

1. http2.0是基于1999年发布的http1.0之后的首次更新
2. 提升了访问速度（请求资源所需事件更少，访问速度更快）
3. 允许多路复用，允许同时通过单一HTTP/2链接发送多重请求-响应信息
4. 改善了http1.1中，浏览器客户端在同一时间针对同一域名下的请求有一定连接数量的限制，超过限制会被阻塞
5. 会将所有的传输信息分割为更凶案的信息或者帧，并对他们进行二进制编码
6. 首部压缩
7. 服务端推送


### 常见的HTTP状态码

描述：http状态码表示客户端http请求的返回结果，标记服务端的处理是否正常或者是出现的错误，能够根据返回的状态码判断请求是否得到正确的处理很重要。状态码由`3位数字`+`原因短语`组成

数字中的第一位制定了相应类别

|     | 类别                      | 原因                               |
| --- | ------------------------- | ---------------------------------- |
| 1xx | Informational，信息状态码 | 接受的请求正在处理                 |
| 2xx | Success，成功状态码       | 请求正常处理完毕                   |
| 3xx | Redirection，重定向       | 需要进行附加操作以完成请求         |
| 4xx | Client error，客户端错误  | 客户端请求出错，服务器无法处理请求 |
| 5xx | Server Error，服务器错误  | 服务器处理请求出错                 |

常见的HTTP状态码

2xx（3种）

 1. 200 OK：表示从客户端发送给服务器的请求被`正常处理并返回`；
 2. 204 No Content：表示客户端发送给服务端的请求得到了处理，但是返回的响应报文中不含实体的主体部分（没有资源可以返回）
 3. 206 Patial content：表示客户端进行了`范围请求`，并且服务器执行了这部分的GET请求，响应报文中包含由`Content-Range`指定范围的实体内容
1

3xx（5种）

1. 301 Moved Permaently：`永久性重定向`，表示请求的资源被分配了新的URL，之后应使用更改的URL
2. 302 Found：`临时性重定向`，表示请求的资源分配了新的URL，希望本次访问使用新的URL

    301和302的区别：301是永久移动，302是临时移动（之后可能还会更改url）

3. 303 See Other：表示请求的资源被分配了新的URL，希望本次访问使用新的URL

    302和303的区别：303明确表示客户端应该采用GET方式获取资源

4. 304 Not Modified：当客户端尝试访问服务器同一页面的时候，如果第二次访问，页面内容并没有发生改变，那么服务器就会返回304

5. 307 Temporary REdirect：`临时重定向`，和303含义相同


4xx（4种）

1. 400 Bad Request：表示请求报文中存在`语法错误`，或者是`页面不存在`

2. 401 Unauthorized：`没有访问权限`，需要身份认证

3. 403 Forbidden：`没有权限访问该资源`

4. 404 Not Found：服务器`没有找到资源`，链接错误、页面不存在、没网络

5xx（2种）

1. 500 Inter Server Error：表示`服务器在执行请求时发生了错误`，也可能是web由应用存在的bug或者临时的错误

2. 503 Server Unavailable：`服务器正处于超负载`或者正在进行停机维护，无法处理请求


### fetch发送两次请求的原因

1. 原因：在进行跨域请求的时候，编写了带预检请求的代码导致多了一次名为`Options`的尝试请求

2. 发送两次请求要满足一下2个条件

    1. 必须是在跨域的情况下

    2. 除了get、head和post（content-type：application/x-www-form-urlencoded，multipart/form-data，text/plain Content-Type）以外的跨域请求


### cookie、sessionStorage、localStorage的区别

相同点：都是保存在浏览器端，并且是同源的

| 方向         | cookie                                                             | localStorage                                             | sessionStorage                                       |
| ------------ | ------------------------------------------------------------------ | -------------------------------------------------------- | ---------------------------------------------------- |
| 生命周期     | 可设置失效时间，没有设置是在关闭浏览器后失效                       | 除非手动清除，否则永久保存                               | 仅在当前网页会话下有效，关闭页面或者浏览器后会被清除 |
| 存放数据大小 | 4kb左右                                                            | 至少5MB                                                  | 至少5MB                                              |
| http请求     | 每次都会携带在http头中，如果使用cookie保存过多数据会带来性能问题   | 仅在浏览器中保存，不参与和服务器的通信                   | 仅在浏览器中保存，不参与和服务器的通信               |
| 易用性       | 需要自己封装，原生的cookie接口不友好                               | 原生接口可以接受，也可以再次封装来对于对象和数组支持更好 | 需要自己封装，原生的cookie接口不友好                 | 原生接口可以接受，也可以再次封装来对于对象和数组支持更好 |
| 应用场景     | 携带cookie浪费带宽，并且需要指定域，限制多，但是常用于识别用户登录 |                                                          |                                                      |
| 兼容性       | 兼容性比较好                                                       | 是html5的新特性，可能有些浏览器不支持                    | 是html5的新特性，可能有些浏览器不支持                |


### Web Worker

1. 概念：是web前端网页上的脚本，提供了一种能在后台进程中运行的方法，一旦它被创建，Web Worker就可以通过`postMessage()`向任务池发送任务请求

2. 特点

   1. Web Worker进程能够在不影响用户界面的情况下处理任务，并且，它还可以使用`XMLHttpRequest`来处理`I/O`，无论`responseXML`和`channel`属性是否为null
   2. 我们可以在浏览器后台运行JavaScript，而不占用浏览器自身线程（webwork实现多线程）。可以提高应用的总体性能，并提升用户体验

3. 应用

    ```js
    1. 通过 worker = new Worker(url); 加载一个js文件来创建一个worker，同时返回一个worker实例

    2. 通过 worker.postMessage(data) 方法来向worker发送数据

    3. 绑定 worker.onmessage 方法来接收worker发送过来的数据

    4. 可以使用 worker.terminate() 来终止一个worker的执行
    ```

4. 例子（不过在本地的chrome运行失败，据说放到服务器上运行可以）

    ```js
    // workerThread1.js	
    let i = 1	
    function simpleCount() {	
    i++	
    self.postMessage(i)	
    setTimeout(simpleCount, 1000)	
    }	
    simpleCount()	
    self.onmessage = ev => {	
    postMessage(ev.data + ' 呵呵~')	
    }
    ```

    ```html
    <!--主线程，HTML文件的body标签中-->	
    <div>	
    Worker 输出内容：<span id='app'></span>	
    <input type='text' title='' id='msg'>	
    <button οnclick='sendMessage()'>发送</button>	
    <button οnclick='stopWorker()'>stop!</button>	
    </div>	
    <script type='text/javascript'>	
    if (typeof(Worker) === 'undefined')    // 使用Worker前检查一下浏览器是否支持	
        document.writeln(' Sorry! No Web Worker support.. ')	
    else {	
        window.w = new Worker('workerThread1.js')	
        window.w.onmessage = ev => {	
        document.getElementById('app').innerHTML = ev.data	
        }	
        window.w.onerror = err => {	
        w.terminate()	
        console.log(error.filename, error.lineno, error.message) // 发生错误的文件名、行号、错误内容	
        }	
        function sendMessage() {	
        const msg = document.getElementById('msg')	
        window.w.postMessage(msg.value)	
        }	
        function stopWorker() {	
        window.w.terminate()	
        }	
    }	
    </script>
    ```


### 对于语义化标签的理解

指构成html结构的标签要有意义

比如nav表示导航，h1-h6表示标题，article、header等

好处

1. 结构清晰，便于维护和阅读
2. 有利于爬虫的SEO
3. 浏览器更方便解析
4. 如果用户网速慢的没有加载出css，页面也能呈现出良好的结构

### iframe是什么，缺点是什么

定义：iframe元素会创建包含另一个文档的内联框架，可以将提示文字放在`<iframe></iframe>`标签之间，来提示不支持iframe的浏览器

缺点

1. 会阻塞页面的onload事件
2. 搜索引擎无法解读这种页面，不利于SEO
3. iframe和主页面共享连接池，而浏览器对于相同区域有限制所以会影响性能


### Doctype的作用？严格模式和混杂模式的区分？他们有何意义？

1. Doctype声明于文档的最前面，告诉浏览器用什么方式来渲染页面，这里有两种模式：严格模式和混杂模式
2. 严格模式的排版和js运作模式是：以该浏览器支持的最高标准运行

   1. 消除js语法不合理、不严谨的地方，减少怪异行为
   2. 消除代码运行的不安全支出，保证代码运行的安全
   3. 提高编译效率，增加运行速度
   4. 为未来新版本的js做好铺垫

3. 混杂模式：向后兼容，模拟老浏览器，防止浏览器无法兼容页面


### cookie如何方法XSS攻击

XSS：跨站脚本攻击，指攻击者再返回的HTML中嵌入js脚本，之后其他用户在观看网页的时候就会受到影响

cookie防范：在http头部配上`set-cookie`


   1. `httponly`这个属性，可以防止XSS，他会禁止js脚本来访问cookie
   2. `secure`这个属性告诉浏览器仅在请求为https的时候发送cookie

结果应该是这样的：`Set-Cookie=<cookie-value>...`


### cookie和session的区别

http是一个无状态协议，因此，cookie最大的作用就是存储`sessionId`来唯一标志用户

|          | cookie       | session      |
| -------- | ------------ | ------------ |
| 数据存放 | 存放在浏览器 | 存放在服务器 |
| 安全性   | 不安全       | 安全         |

session在一段时间之内回报存在服务器上，当访问增多，会比较占用服务器的性能，这种情况可以考虑使用cookie

cookie保存的数据不能超过4k，很多浏览器限制一个站点最多保存20个cookie


### 讲讲 viewport 和移动端布局

见文章[https://github.com/forthealllight/blog/issues/13](https://github.com/forthealllight/blog/issues/13)


### click在ios上面有300ms的延迟，原因和解决方案

原因：ios为了能够把pc大屏幕的页面较好效果显示在小屏幕手机端上阿敏，采用了双击缩放的方案，由于需要浏览器区分单机还是双击的操作，所以设置了300ms的延迟

方案

   1. 粗暴型：禁用缩放

        ```html
        <meta name="viewport" content="width=device-width,user-scalable=no">
        ```

   2. FastClick

        原理：监测到`touched`事件之后，立刻触发click事件，并且把300ms之后真正触发的事件阻拦

        ```js
        window.addEventListener('load', function() {
            FastClick.attach(document.body);
        }, false)
        ```

### addEventListener参数

addEventListener(event, function ,useCapture)

1. event：指定事件名
2. functin：触发函数
3. useCapture：指定事件是否在捕获或者冒泡阶段执行


### http常用请求头

| 字段            | 说明                                                                                                                            |
| --------------- | ------------------------------------------------------------------------------------------------------------------------------- |
| Accept          | 可接受的响应内容类型（Content-Type）                                                                                            |
| Accept-Charset  | 可接受的字符集                                                                                                                  |
| Accept-Encoding | 可接受的响应内容的编码方式                                                                                                      |
| Accept-Language | 可接受的响应内容的语言列表                                                                                                      |
| Accept-Datetime | 可接受的按照时间来表示的响应内容版本                                                                                            |
| Authorization   | 用于表示HTTP协议中需要认证资源的认证信息                                                                                        |
| Cache-Control   | 用来指定当前的请求/回复中的，是否使用缓存机制                                                                                   |
| Connection      | 客户端想要优先使用的连接类型                                                                                                    |
| Cookie          | 服务器通过Set-Cookie设置的HTTP协议的Cookie                                                                                      |
| Content-Length  | 8进制表示的请求体的长度                                                                                                         |
| Expect          | 客户端要求服务器做出特定的行为                                                                                                  |
| Host            | 服务器的域名以及服务器监听的端口号，如果端口号是80则可以省略                                                                    |
| Origin          | 发起一个针对跨域资源共享的请求（该请求要求服务器在响应中加上一个`Access-Control-Allow-Origin`的消息头，表示访问控制所允许的来源 |
| Referer         | 表示浏览器所访问的前一个页面，可以认为是之前访问页面的链接将浏览器带到了当前页面                                                |
| Upgrade         | 要求服务器升级到一个高版本的协议                                                                                                |
| User-Agent      | 浏览器的身份标志字符串                                                                                                          |


### 强缓存和协商缓存

缓存分为两种：强缓存和协商缓存，根据响应的`header`内容来决定

|                  | 强缓存                                                                                          | 协商缓存                                            |
| ---------------- | ----------------------------------------------------------------------------------------------- | --------------------------------------------------- |
| 获取资源形式     | 从缓存取                                                                                        | 从缓存取                                            |
| 状态码           | 200（from cache）                                                                               | 304（not modified）                                 |
| 发送请求到服务器 | 否，直接从缓存中取                                                                              | 是，通过服务器来告知缓存是否可用                    |
| 相关字段         | expires/cache-control，如果cache-control和expires同时存在的话，cache-control的优先级高于expires | Last-Modified/If-Modified-Since，Etag/If-None-Match |


### 前端优化方向

1. 降低请求量：合并资源、减少http请求数、minify/gzip压缩、webP（一种压缩的图片格式）、lazyLoad

2. 加快请求速度：预解析DNS、减少域名数、并行加载、CDN分发

3. 缓存：http协议缓存请求、离线缓存manifest、离线数据缓存localstorage

4. 渲染：JS/CSS优化、加载顺序、服务端渲染、pipeline


### post和get的区别

|           | GET                                                       | POST             |
| --------- | --------------------------------------------------------- | ---------------- |
| 参数      | 通过url传递                                               | 放在body中       |
| 参数长度  | 有url长度限制，如ie最少为2048                             | 无限制           |
| 安全性    | 参数直接暴露在url中，并且回报存在浏览器历史记录中，不安全 |                  |
| 编码      | 只能进行url编码                                           | 支持多种编码方式 |
| TCP数据包 | 产生一个                                                  | 产生2个          |


### http支持的方法及作用

| 方法    | 作用           |
| ------- | -------------- |
| get     | 获取资源       |
| post    | 传输实体的主体 |
| put     | 传输文件       |
| head    | 获取报文首部   |
| delete  | 删除文件       |
| options | 询问支持的方法 |


### 浏览器输入url到页面渲染过程

三大过程

1. dns解析url（将域名翻译为ip地址）

    1. 从浏览器dns缓存中查找是否有缓存
    2. 向服务器发出请求进行递归查询ip地址

2. 浏览器和服务器进行交互

    1. 浏览器利用TCP协议进行3次握手和服务器建立连接
    2. 浏览器根据解析到的ip地址和端口发起http的请求
    3. 服务器接收到请求之后返回响应报文
    4. 浏览器接收到数据之后，准备进行页面的渲染

3. 浏览器渲染页面的过程

    1. 浏览器将html节点遍历为dom树
    2. 将css解析成cssom规则树
    3. 将dom树和cssom规则树构造成render树
    4. js根据render树计算所有节点在屏幕中的位置，进行布局（回流）
    5. 遍历render树并调用硬件api绘制所有节点（重绘）


### 常见的http的头部

1. 通用首部：一些通用信息，如date表示创建时间

2. 请求首部：请求报文独有的，如cookie

3. 响应首部：响应报文独有的，如set-cookie

4. 实体首部：描述实体的部分，allow用来描述可执行的请求方法，content-type描述主体类型


### 怎么看网站的性能如何

1. 被动检测：在被检测的页面植入脚本或者探针，当用户访问网页的时候，探针自动采集数据并传回数据库进行分析

2. 主动检测：模拟用户发起页面访问请求，主动采集性能数据并分析，在检测的精准度上面，专业的第三方工具更佳，比如性能极客


### html5和css3的新特性

1. html5

    1. 语义化标签：header、footer、nav
    2. 增强型表单：input的一些type，coor，date，email，tel
    3. 新增的表单属性：placeholder、reduired、pattern
    4. 新事件：onresize、ondrag、onscroll

2. css3

    1. 选择器

       1. 伪类：向某些选择器添加特殊效果，hover、link、active、last-child，没有创建新元素
       2. 伪元素：创建了html中不存在的元素，将特殊的效果添加到选择器，before、afater、first-latter

    2. 背景和边框

        1. 背景：background-size、background-origin
        2. 边框：圆角、阴影

    3. 文本效果：text-shadow、text-justify、text-outline

    4. 2D/3D转换：变形、过渡、动画








## CSS












## JS



### get传参的误区

1. http协议没有规定get和post传参的长度限制
2. get的长度限制是由于浏览器和服务器限制了URI的长度
3. 不同的浏览器和web服务器，限制的长度不一样，如IE为2048byte，chrome为8182byte


### 说一下闭包

1. 概念

   1. 他是一个函数
   2. 能够读取其他函数内部的变量
   3. 创建闭包最常见的方式就是在一个函数内部创建另一个函数

2. 作用

    1. 延长外部函数变量对象的生命周期
    2. 间接从函数外部访问函数内部的私有变量
    3. 避免使用全局变量导致的全局变量污染

3. 缺点

    1. 常驻内存，会增大内存使用量，并且使用不当很容易造成内存泄漏
    2. 对js性能有负面影响，如处理速度和内存消耗
    3. 在闭包之后手动置空闭包变量

简单的闭包例子

```js
function demo() {
    let a = 1;
    return function() {
        return a;
    }
}
let b = demo();
console.log(b);
```

解释：通常，函数的作用域和他所有变量都会在函数执行结束后销毁，但是创建了一个闭包之后，这个函数的作用域就会一直保存到闭包不存在为止


```js
function demo(x) {
    return function(y) {
        return x + y;
    }
}
let a = demo(1);
let b = demo(2);

console.log(a(10)); // 11
console.log(b(20)); // 22

// 释放对于闭包的引用
a = null;
b = null;
```

解释：a和b都是闭包。它们共享相同的函数定义，但是保存了不同的环境。a中的x为1，b中的x为2。最后通过null释放了a和b对闭包的引用。

在js中，如果一个对象不再被引用，那么这个对象就会被垃圾回收机制回收。如果两个对象相互引用，而不再被第三者引用，那么这两个相互引用的对象也会被回收。

`闭包只能够取得包含函数中任何一个变量的最后一个值`

```js
function arrFun() {
    let arr = [];
    for(let i=0; i<10; i++) {
        arr[i] = function() {
            return i;
        }
    }
    return arr;
}
```

arr数组中包含了10个匿名函数，每一个匿名函数都能够访问外部函数的变量i，那么i是多少呢？


应用场景

1. 原生的setTimeout传递的第一个函数不能带参数，通过闭包可以实现传参效果

```js
function f1(a) {
    return function() {
        console.log(a);
    }
}
let fun = f1(1);
setTimeout(fun, 1000);

// 对比错误的效果
// let a = 1;
// setTimeout(() => {
//     console.log(a);
// }, 1000);
// a = 2;
```
2. 回调

    定义一个行为，然后把它关联到某一个用户事件上（点击或者按键），代码通常作为一个回到绑定到事件

    ```html
    <!DOCTYPE html>
    <html lang="en">
    <head>
        <meta charset="UTF-8">
        <title>测试</title>
    </head>
    <body>
        <a href=" " id="size-12">12</a>
        <a href="#" id="size-20">20</a>
        <a href="#" id="size-30">30</a>

        <script type="text/javascript">
            function changeSize(size){
                return function(){
                    document.body.style.fontSize = size + 'px';
                };
            }

            var size12 = changeSize(12);
            var size14 = changeSize(20);
            var size16 = changeSize(30);

            document.getElementById('size-12').onclick = size12;
            document.getElementById('size-20').onclick = size14;
            document.getElementById('size-30').onclick = size16;

        </script>
    </body>
    </html>
    ```

3. 函数防抖

    在事件被触发n秒后执行回调，如果在这n秒内又被触发，则重新计时

    实现的关键在于`setTimeout`这个函数，由于还需要一个变量来保存计时，考虑维护全局纯净，可以借助闭包来实现。

    ```js
    function debounce(fn, delay) {
        let timer = null;
        // 借助闭包
        return function() {
            if (timer) {
                // 进入这个分支，说明当前有一个计时过程中，并且又触发了相同事件，所以要取消当前的计时
                clearTimeout(timer);
            }
            // 重新开始计时
            timer = setTimeout(fn, delay);
        } 
    }
    ```

4. 创建私有变量

    用js创建一个计数器

    ```js
    function fun() {
        let sum = 0;
        let obj = {
            inc: function() {
                sum++;
                return sum;
            }
        }
        return obj;
    }
    let res = fun();
    res.inc();
    res.inc();
    res.inc();
    ```


### 说一下类的创建和继承

1. 类的创建（es5）：`new`一个`function`，在这个function的`prototype`里面增加属性和方法

    ```js
    // 定义一个动物类
    function Animal(name) {
        // 属性
        this.name = name || 'Animal';
        // 实例方法
        this.sleep = function() {
            console.log(this.name + 'is sleeping');
        }
    }

    // 原型方法
    Animal.prototype.eat = function(food) {
        cosnole.log(this.name + 'eatting' + food);
    }
    ```

    这样就生成了一个Animal类，实例化生成对象之后，有方法和属性

2. 类的继承：原型链继承

    ```js
    // 定义一个猫类
    function Cat() {}
    Cat.prototype = new Animal();
    Cat.prototype.name = 'cat';

    // 使用实例来调用方法
    var cat = new Cat();
    console.log(cat.name);
    console.log(cat.eat('fish'));
    console.log(cat.sleep());
    console.log(cat instanceof Animal); // true
    console.log(cat instanceof Cat); // true
    ```

    核心概念：将`父级`的实例指向`子级`的原型，这就是原型链继承

    特点：基于原型链，既是父类的实例，又是子类的实例

    缺点：无法实现多继承

3. 构造继承：使用父类的构造函数来增强子类实例，等于是复制父类的实例属性给子类（没用到原型）

    ```js
    function Cat(name) {
        Animal.call(this);
        this.name = name || 'Tom';
    }
    var cat = new Cat();
    console.log(cat.name);
    console.log(cat.sleep());
    console.log(cat instanceof Animal); // false
    console.log(cat instanceof Cat); // false
    ```

    特点：可以实现多继承

    缺点：只能继承父类实例的属性和方法，不能继承原型上的属性和方法

4. 实例继承和拷贝继承（实用性不强）

    实例继承：为父实例添加新特性，作为子类实例返回

    拷贝继承：拷贝父类元素上的属性和方法

5. 组合继承：相当于构造继承和原型继承的组合体。通过调用父类构造，继承父类的属性并保留传参的优点，然后将父类实例作为子类原型，实现函数复用

    ```js
    function Cat(name) {
        Animal.call(this);
        this.name = name || 'Tom';
    }
    Cat.prototype = new Animal();
    Cat.prototype.constructor = Cat;

    var cat = new Cat();
    console.log(cat.name);
    console.log(cat.sleep());
    console.log(cat instanceof Animal); // true
    console.log(cat instanceof Cat); // true
    ```

    特点：可以集成实例属性/方法，也可以继承原型属性/方法

    缺点：调用了两次父类构造函数，生成了两份实例

6. 寄生组合继承：通过寄生方式，砍掉父类的实例属性，这样，在调用父类的构造的时候，就不会初始化两次实例方法/属性

    ```js
    function Cat(name) {
        Animal.call(this);
        this.name = name || 'Tom';
    }
    (function() {
        // 创建一个没有实例方法的类
        var Super = function() {};
        Super.prototype = Animal.prototype;
        // 将实例作为子类的原型
        Cat.prototype = new Super();
    })();

    var cat = new Cat();
    console.log(cat.name);
    console.log(cat.sleep());
    console.log(cat instanceof Animal); // true
    console.log(cat instanceof Cat); // true
    ```

    比较推荐这种方式


### 如何解决异步回调地狱

1. 什么是`回调地狱`

    当一个函数作为参数传入另一个函数中，并且它不会立即执行，只有当满足一定条件后该函数才会执行，这种函数就称为回调函数。而回调地狱就是在回调函数上重重嵌套，使代码可读性非常差

    如，

    ```js
    //回调地狱
    setTimeout(function () {  //第一层
        console.log('111');//等3秒打印111在执行下一个回调函数
        setTimeout(function () {  //第二层
            console.log('222');//等2秒打印222在执行下一个回调函数
            setTimeout(function () {   //第三层
                console.log('333');//等一秒打印333
            }, 1000)
        }, 2000)
    }, 3000)
    ```

2. 解决回调地狱的方法

    1. 生成器（es6中的语法Generator）

        1. 生成器是一个特殊的函数（在函数名前面加一个`*`号），用来解决异步编程的回调地狱问题，语法行为和传统函数完全不同

        2. `yield`语句：函数代码的分隔符，把函数代码切割成几块通过`next()`来控制代码的向下执行

        3. 使用`iterator`迭代器对象，说明可以使用`for of`来遍历，每一次调用返回的结果是`yield`后面的内容

        4. `next`执行的时候可以传参，参数将作为上一个`yield`语句整体返回结果

        ```js
        // 需求 只有拿到用户基础信息之后才能拿到用户的订单信息，再拿到用户订单信息
        function one(aa) {
            setTimeout(() => {
                iterator.next('用户信息');
            }, 100)
        }
        function two() {
            setTimeout(() => {
                iterator.next('订单信息');
            }, 100);
        }
        function three() {
            setTimeout(() => {
                iterator.next('商品信息');
            }, 100);
        }
        function *getInfo() {
            let userInfo = yield one();
            console.log('userInfo', userInfo);
            let orderInfo = yield two();
            console.log('orderInfo', orderInfo);
            let goodsInfo = yield three();
            console.log('goodsInfo', goodsInfo);
        }
        let iterator = getInfo();
        iterator.next(); //控制台里依次打印出用户信息  订单信息  商品信息
        ```

    2. Promise

        es6中引入的一步变成的新解决方案，语法上`Promise`是一个构造函数，用来封装异步操作并可以获取其成功或者失败的结果

        例子

        ```js
        function fun(num) {
            return new Promise(resolve => {
                setTimeout(() => {
                    resolve('success');
                    console.log(num);
                }, 100);
            })
        }
        let p = fun(1);
        p.then(() => {
            return fun(2);
        })
        .then(() => {
            return fun(3);
        })
        ```

    3. async-await

        他是es8的新特性

        1. async函数的返回值是一个`promise`对象
        2. `promise`对象的结果由`async`函数执行的返回值决定
        3. `await`必须写在`async`函数中（在浏览器环境不需要，在node环境中需要放在`async`中）
        4. `await`右侧的表达式一般为`promise`对象
        5. `await`返回的是`promise`成功的值
        6. `await`的`promise`失败了，就会抛出异常，要用`try-catch`捕获处理
        7. 返回的结果如果不是一个`Promise`对象，则函数返回的结果就是一个成功的`Promise`对象
        8. 如果返回的结果是一个`promise`对象，则成功的`promise`的值就是该函数成功的值

        ```js
        function fun(num) {
            return new Promise(resolve => {
                setTimeout(() => {
                    resolve('success');
                    console.log(num);
                }, 100);
            })
        }
        (async function() {
            await fun(1);
            await fun(2);
            await fun(3);
        })()
        ```

### 说说前端中的事件流

html和js交互是通过事件驱动来实现的，例如鼠标点击事件onclick，页面的滚动事件onscroll等等，可以向文档或者文档中的元素添加事件侦听器来预定事件，想要知道这些事件是在什么时候进行调用的，就需要了解一下`事件流`的概念。

事件流：事件流描述的是从页面接收事件的顺序，`DOM2`级事件流包括下面几个阶段。

1. 事件捕获阶段
2. 处于目标阶段
3. 事件冒泡阶段

`addEventListener`：是`DOM2`级事件新增的指定事件处理程序的操作，这个方法接收3个参数，要处理的事件名、作为事件处理程序的函数和一个布尔值。最后这布尔值参数如果是true，表示在捕获阶段调用处理程序；如果是false表示在冒泡阶段调用事件处理程序。

IE只支持事件冒泡


### 如何让事件先冒泡再捕获

在DOM标准事件模型中，是先捕获再冒泡。但是如果要实现先冒泡后捕获的效果，对于同一个事件，监听捕获和冒泡，分别对应相应的树立韩束，监听到捕获事件，先暂缓执行，直到冒泡事件被捕获后再执行捕获事件


### 说一下事件委托（事件代理）

1. 概念

    不在事件的发生地（直接DOM）上设置监听函数，而是在其父元素上设置监听函数，通过事件冒泡，父元素可以监听到子元素上事件的触发，通过判断事件发生元素DOM的类型（通过`target`找到），来做出不同的响应。

2. 例子

    在`ul-li`列表中，想要为每一个`li`元素绑定一个点击事件，如果单纯的对于每一个`li`元素都绑定一个事件的话，如果`li`比较多的话，会造成性能的降低。

    如果使用事件代理的话，可以给`ul`元素绑定点击事件，达到相同的效果，通过`target`找到实际发生的li元素

    ```html
    <!DOCTYPE html>
    <html>
    <head>
        <title>event</title>
    </head>
    <body>
        <div id="obj1">
            welcome
            <h5 id="obj2">hello</h5>
            <h5 id="obj3">world</h5>
        </div>
        <script type="text/javascript">
            var obj1=document.getElementById('obj1');
            // var obj2=document.getElementById('obj2');
            // obj1.addEventListener('click',function(){
            //     alert('hello');
            // },false);
            // obj2.addEventListener('click',function(){
            //     alert('world');
            // })
            obj1.addEventListener('click',function(e){
                var e=e||window.event;
                if(e.target.nodeName.toLowerCase()=='h5'){
                    alert(e.target.innerHTML);
                }
    
    },false);
        </script>
    </body>
    </html> 
    ```

3. 优点

    比较适合动态元素的绑定，新添加的子元素也会有监听函数，也可以有事件触发机制


### 说一下图片的懒加载和预加载

1. 预加载：提前加载图片，当用户需要查看时可以直接从本地缓存中渲染

2. 懒加载：主要目的是作为服务器前端的优化，减少请求数或者延迟请求数

3. 两种技术的本质：都是提高页面性能的方式，行为是相反的，一个是提前加载，一个是延缓加载，甚至是不加载。懒加载对于服务器前端有一定的缓解压力的作用，预加载则会增加服务器的前端压力。

4. 应用场景

    适用于图片很多，页面很长的电商网站的场景

5. 原理

    懒加载：将页面上图片的`src`属性设置为空字符串，将图片的真实路径保存在一个自定义属性中，当页面滚动的时候，进行判断，如果图片进入页面可视区域内，则从自定义属性中取出真实路径赋值给图片的src属性，以此来实现图片的延迟加载

    预加载：最常用的方式是使用js中的`image`对象，通过为`image`对象来设置src属性，来实现上图片的预加载


### js的new操作符做了哪些事情

    > var p = new Person();

    ```js
    // 创建一个空对象
    var o = new Object();
    // 设置原型链，让该对象继承构造函数的原型
    o.__proto__ = Person.prototype;
    // 把构造函数的this指向新对象，并执行函数体
    var result = Person.call(o);
    // 判断构造函数的返回值类型，如果是值类型则返回该对象，如果是引用类型，就返回这个引用类型的对象
    if (typeof(result) === 'object') {
        obj = result;
    } else {
        obj = o;
    }
    ```

    模拟`new`操作

    ```js
    function New(obj, ...arg) {
        // 创建新对象，原型为构造函数的原型
        // 可以拆分写法，如下
        // let newObj = {};
        // newObj.__proto = obj.prototype;
        let newObj = Object.create(obj.prototype);
        // 修改this指向为新对象，并执行函数体
        let result = obj.apply(res, arg);
        // 如果返回值不是有效对象，则返回新对象
        return (typeof result === 'object') ? result : res;
    }
    ```

### bind、apply、call的区别

相同点：都用于改变`this`指向的绑定

不同点：

1. call、apply会`立即执行函数`。`call`传递参数调用形参是以散列的形式（`fn.call(obj,1,2,3)`），而`apply`的形参是一个数组。在传参的情况下，`call`的性能要高于`apply`，因为`apply`在执行的时候还要多一步解析数组

2. `bind`在改变`this`之后返回的是一个全新的绑定函数，即返回一个新的函数，不会立即执行函数。并且之后的`this`指向无法再通过call、apply、bind改变。


### JS异步加载

1. 同步加载

    1. 默认正常的模式下，js是同步加载的，只有当js文件下载完，dom和css才开始加载。

    2. 同步加载是使用最多的一种方式，又称为阻塞模式，会阻止浏览器的后续处理，停止后续的解析，要等js加载完并执行之后才能执行下一步，所以默认同步执行是`最安全`的

    3. 但是如果js中有`输出documenet内容`、`修改dom`、`重定向`等性行为，就会造成页面阻塞，所以一般建议把`<script>`标签放在页面末尾的`<body>`之前，这样尽可能减少这种阻塞行为，而先展示出来

    4. 简单说：加载的网络`timeline`是瀑布模型，而异步加载的`timeline`是并发模型

2. 常见异步加载（Script DOM Element）

    ```js
    (function() {
        var s = document.createElement('script');
        s.type = 'text/javascript';
        s.async = true;
        s.src = 'http://xxx.com/script.js';
        var x = document.getElementsByTagName('script')[0];
        x.parentNode.insertBefore(s, x);
    })()
    ```

    1. 异步加载又叫非阻塞模式，浏览器在下载执行js的同时，还会继续进行后续页面的处理

    2. 这种方法是在页面中`script`标签内，用js创建一个`script`元素并插入到`document`中，这样就做到了非阻塞的下载js代码

    3. `async`是html5中新增的异步支持，加上好一些（不加也不影响）。这种方法成为`script dom element`法，不要求js同源

    4. 将js代码包裹在匿名函数中并立即执行的方式是为了保护变量名泄漏到外部可见，这是很常见的方式，尤其是在js库中被普遍使用

    5. 但是这种加载方式在加载执行完之前会阻止onload事件的触发，而现在很多页面的代码都在onload时还要执行额外的渲染工作等，所以还是会阻塞部分页面的初始化处理。

3. onload时的异步加载

    ```js
    (function() {
        function async_load() {
            var s = document.createElement('script');
            s.type = 'text/javascript';
            s.async = true;
            s.src = 'http://xxx.com/script.js';
            var x = document.getElementsByTagName('script')[0];
            x.parentNode.insertBefore(s, x);
        }
        if (window.attachEvent) {
            window.attachEvent('onload', async_load);
        } else {
            window.addEventListener('load', async_load, false);
        }
    })();
    ```

    这和前面的方式差不多，但关键是它并不是立即开始异步加载js，而是在onload时才开始异步加载，这样就解决了阻塞onload事件触发的问题


4. async和defer属性

    1. defer属性

        ```html
        <script src="xxx.js" defer></script>
        ```

        `defer`属性声明这个脚本中将不会有`document.write`或`dom`修改。浏览器将会并行下载`xxx.js`和其他有`defer`属性的`script`，二部会阻塞页面的后续处理。

    2. async属性

        ```html
        <script src="xxx.js" async></script>
        ```

        async属性是html5新增的，作用和defer类似，但是他将在下载后尽快执行，不能保证脚本会按顺序执行，他们将在onload事件之前完成


### ajax解决浏览器缓存问题

1. 在ajax发送请求前加上：`anyAjaxObj.setRequestHdader("If-Modified-Since": "0")`
2. 在ajax发送请求前加上：`anyAjaxObj.setRequestHdader("Cache-Control": "no-cache")`
3. 在url后面加上一个随机数：`"fresh=" + Match.random()`
4. 在url后面加上时间戳：`"nowtime=" + new Date().getTime()`


### JS的节流和防抖

0. [参考文章](https://segmentfault.com/a/1190000018428170)

1. 使用场景：适用于高频触发的函数或事件，快速连续触发和不可控的高频触发

    如：鼠标移动事件，窗口放大缩小，input输入

    影响：响应跟不上触发，导致页面卡顿、假死现象

2. 防抖：debounce

    1. 介绍：当事件触发时，设定一个周期延迟执行动作，如果期间又被触发，则重新设定周期，直到周期结束，才会执行动作。

    2. 例子：监听页面滚动事件,如果靠近底部则出现回到顶部按钮

        ```js
        function showTop() {
            var scrollTop = document.body.scrollTop || document.documentElement.scrollTop;
            console.log('滚动条位置：', scrollTop);
        }
        window.onscroll = showTop;
        ```

        如果这样写的话执行频率太高，进行防抖处理

        ```js
        function debounce(fn, delay) {
            let timer = null;
            return function() {
                if (timer) {
                    clearTimeout(timer);
                }
                timer = setTimeout(fn, delay);
            }
        }
        window.onscroll = debounce(showTop, 1000);
        ```

3. 节流：throttle

    1. 介绍：不定周期内，只执行一次动作，如果在周期内有新事件触发，不执行（`这里不会重新设定周期`）。周期结束后，如果又有事件触发，又开始新的周期。

    2. 例子：监听页面滚动事件,如果靠近底部则出现回到顶部按钮

        使用上面的防抖方法的话，会导致，如果页面一直在滚动，那么永远只会执行一次，如果想在这种情况下每隔一段时间再执行的话考虑使用节流。

        ```js
        function throttle(fn, delay) {
            let valid = true;
            return function() {
                if (!valid) {
                    return false;
                }
                valid = false;
                setTimeout(() => {
                    fn();
                    valid = true;
                }, delay);
            }
        }
        window.onscroll = throttle(showTop, 1000);
        ```

4. 区别：是否会重新设定周期（如果很长一段时间都在触发事件的话，防抖只会执行一次，节流可执行多次）

5. 选择策略

    防抖：操作高频触发，但有停顿。窗口拉伸，联想搜索。

    节流：操作高频触发，连续不断。页面滚动，鼠标不断点击。


### JS的垃圾回收机制

1. 什么是垃圾

   1. 没有被引用的对象或变量
   2. 无法访问到的对象（几个对象引用形成一个环，相互引用）

2. 什么是内存泄漏

    当已经不需要某块内存的时候，这块内存还存在，没有释放，导致该内存无法被使用

3. 垃圾回收机制（GC）

    1. 执行环境负责管理代码执行过程中使用的内存。
    2. 为了防止内存泄漏
    3. 间歇不定期的寻找到不再使用的变量，并释放掉它们指向的内存

4. 垃圾回收的必要性

    1. 字符串、对象和数组没有固定的大小，所以只有当他们大小已知时才能对他们进行动态存储的分配
    2. js每次创建字符串、数组和对象的时候，解释器都要分配内存才会存储这个实体
    3. 只要动态分配了内存，最终都要释放这些内存以便他们能够再次利用
    4. 否则，js的解释器将会消耗系统中所有可用的内存，造成系统崩溃

5. 垃圾回收方式

    1. 标记清除（js最常用的垃圾回收方式）

        1. 当变量进入执行环境时（函数中声明变量），就标记这个变量“进入环境”，当变量离开环境时（函数执行结束），则将其标记为“离开环境”，离开环境之后还有的变量则是需要被删除的变量
        2. 垃圾回收器在运行的时候会给存储在内存中的所有变量都加上标记
        3. 去掉“环境中的变量”以及“环境中的变量引用的变量”的标记
        4. 之后再加上标记的变量就是需要回收的变量（因为环境中的变量已经无法访问到这些变量）
        5. 最后，垃圾收集器完成内存清除工作，销毁那些带标记的值，并回收他们所占用的内存空间

    2. 引用计数

        1. 这种方式经常会引起`内存泄漏`，低版本的`IE`使用这种方式
        2. 机制：

           1. 跟踪一个值的引用次数
           2. 当声明一个变量并将一个引用类型赋值给该变量时引用次数加一
           3. 当这个变量指向其他时，该值的引用次数便减一
           4. 当该值的引用次数为0时，则说明没有办法在访问这个值了，视为准备回收的对象
           5. 每过一段时间，开始垃圾回收的时候，就把这些引用数为0的变量回收
           6. 引用计数法可能导致循环引用，类似死锁，导致内存泄露

6. 常见内存泄漏的原因

    1. 全局变量引起的内存泄漏
    2. 闭包引起的内存泄漏
    3. dom清空或删除时，事件未清除导致的内存泄漏
    4. 循环引用带来的内存泄漏


### eval

1. 作用：将字符串参数解析成js代码并运行，然后返回运行的结果

    ```js
    eval('2+3'); // 5
    ```
2. eval的作用域在他所拥有的的范围内有效

3. 注意事项

    应该避免使用eval，不安全，非常消耗性能（一次解析成js，一次运行）

4. 特殊作用：将字符串json转化为json对象

    ```js
    let str = '{name: "lan"}';
    let s = `(${str})`;
    let o = JSON.parse(s); // {name: "lan"}
    ```


### 如何理解前端模块化

1. 将复杂的文件变成一个一个独立的模块，比如JS文件等

2. 分成独立的模块有利于重用（复用性）和维护（版本迭代），

3. 这样会引来模块之间相互依赖的问题，所有有了`commonJS`规范，以及用于JS打包（编译等处理）的工具`webpack`


### 将原生的ajax封装成promise

```js
function newAjax(url, data) {
    return new Promise((resolve, reject) => {
        let xhr = new XMLHttpRequest();
        xhr.open('get', url);
        xhr.send(data);
        xhr.onreadystatechange = function() {
            if (xhr.status === 200 && readyState === 4) {
                resolve(JSON.parse(xhr.responseText));
            } else {
                reject('error');
            }
        }
    });
}
```


### JS监听对象属性的改变

1. es5中可以同过`Object.defineProperty`来实现已有属性的监听

    ```js
    let user = {name: 'lan'};
    Object.defineProperty(user, 'name', {
        set: function(value) {
            console.log('name改变了', value);
        },
        get: function() {
            console.log('访问name了');
        }
    })
    ```

2. es6中可以通过`Proxy`来实现

    ```js
    let user = new Proxy({}, {
        set: function(target, key, value) {
            console.log('user改变了', target, key, value);
        }
    })
    ```

    优点：可以针对不存在的属性进行监听


### 创建一个私有变量，用getName()方法可以访问，不能直接访问

1. 通过函数

    ```js
    function Private(){
        let a = '私有变量';
        this.getName = function() {
            return a;
        }
    }
    let obj = new Private();
    console.log(obj.a)  // undefine
    console.log(obj.getName()); // 私有变量
    ```

2. 类构造器

    ```js
    class Private {
        constructor() {
            let a = '私有变量';
            this.getName = function() {
                return a;
            }
        }
    }
    let p = new Private();
    console.log(p.a);
    console.log(p.getName());
    ```


### setInterval的缺陷及解决方案

缺陷：

1. 对于自己调用的代码是否报错不关心，即使报错了，依然会执行下去

    ```js
    setInterval(() => {
        console.log('hhh')
        console.log('一个不存在的变量', notExit);
    }, 1000)
    ```

2. 无视网络延迟，使用`轮询`的时候，如果网络不好，会导致网络请求堆积

3. 如果调用的代码执行时间小于定时的时间，就会跳过调用，会导致执行的次数不对，或者无法得到想要的结果

解决方案：使用`setTimeout`来实现`setInterval`

```js
function mySetInterval(fn, delay, times) {
    let timer = setTimeout(function a() {
        fn()
        times--
        timer = setTimeout(a, delay)
        if (times <= 0) {
            clearTimeout(timer)
        }
    }, delay)
}
mySetInterval(() => console.log('hhh'), 500, 5)
```


### 简单实现 Node 的 Events 模块

> https://blog.csdn.net/wenyeqv/article/details/124962290


### 判断数据类型的几种方式

1. typeof

    ```js
    let a = 123;
    typeof a; // 'number'
    ```

    用于判断除了对象之外的类型比较方便，可以用来判断函数，不能判断数组

2. instanceof

    ```js
    let a = [1, 2];
    a instanceof Array; // true
    ```

    用于判断已知对象类型

3. constructor

    ```js
    let a = [1, 2];
    a.constructor === Array;
    ```

    根据对象的构造函数判断

    但是在类继承的时候会出错


### 数组去重方式

1. indexOf循环去重（includes类似）

    ```js
    let arr = [1, 6, 2, 3, 2, 4, 5, 6, 7];
    let newArr = [];
    arr.forEach(item => {
        if (newArr.indexOf(item) === -1) {
            newArr.push(item);
        }
    })
    ```
2. 使用set去重

    ```js
    let newArr = [...new Set(arr)];
    ```

3. 使用filter去重

    ```js
    let arr = [1, 6, 2, 3, 2, 4, 5, 6, 7];
    let newArr = arr.filter((item, index) => {
        return arr.indexOf(item) === index;
    });
    ```


### JS语言特性

1. 运行在客户端浏览器上
2. 不用预编译，直接解析执行代码
3. 是弱类型语言，较为灵活
4. 与操作系统无关，跨平台的语言
5. 脚本语言，解释性语言


### 重绘和重排

重排：当DOM的变化引发了元素`几何属性`的变化，比如改变元素宽高、元素位置等，导致浏览器不得不重新计算元素的几何属性，并重新构建渲染树。

重绘：完成重排后，要将重新构建的渲染树渲染到屏幕上，这个过程就是重绘。

简单的说，重排负责元素的几何属性更新，重绘负责元素的样式更新。重排必定带来重绘，重绘未必带来 重排。比如改变元素的背景，不涉及元素的几何属性，这个只发生重绘。

元素几何属性：

1. 添加或删除可见的DOM元素
2. 元素位置改变
3. 元素本身尺寸发生改变
4. 内容改变
5. 页面渲染器初始化
6. 浏览器窗口大小发生改变

如何进行性能优化，参见这篇[文章](https://www.cnblogs.com/soyxiaobi/p/9963019.html)


### JS全排列

1. 题目描述

    输入一个字符串，按字典序打印出该字符串中字符的所有排列。例如输入`abc`则打印出abc所有可能的排列`abc/acb/bac/bca/cab/cba`

2. 基本思路

    采用`插空`的方法：每次选一个字符，然后在剩余字符串中进行插空

    例如，字符串【abc】，取出a，剩余【bc】，可以形成3个间隔`()b()c()`或者`()c()b()`一共两种方案，然后将a插入到3个空中，所以总共有6种方案

3. 代码实现

    ```js
    function permutation(str) {
        if (str.length === 0) {
            return [];
        }
        if (str.length === 1) {
            return [str];
        }
        let result = [];
        // 把str分成两部分，第一部分分为第一个字母str[0]，第二部分为剩余的字符串str.slice(1)
        // 把permutation(str.slice(1))作为一个已知量
        let rest = permutation(str.slice(1));
        for (let i=0; i < rest.length; i++) {
            for (let j=0; j < rest[i].length + 1; j++) {
                let temp = rest[i].slice(0, j) + str[0] + rest[i].slice(j);
                result.push(temp);
            }
        }
        // 去掉result中重复的元素
        let res = [...new Set(result)];
        return res.sort();
    }
    ```


### 暂停死区

在代码块内，使用`let`、`const`命令声明变量之前，该变量都是不可用的。这在语法上，称为【暂时性死区】


### 有一个游戏叫做小鸟飞，玩这个游戏的时候老是卡顿

原因及解决方案

1. 内存溢出问题：可以在钢管离开可视区域后，销毁钢管，让垃圾回收器回收钢管，因为不断生成的钢管不及时清理容易导致内存溢出游戏崩溃

2. 资源过大问题：选择图片文件大小更小的格式的图片，因为绘制图片需要较大计算量

3. 资源加载问题：我们应该在可视区域之前就预加载好资源，如果在可视区域生成钢管的话，用户的体验就是认为钢管式卡顿之后才生成的，不流畅

4. canvas绘制频率问题：大部分显示器的刷新频率为60次/秒，因为游戏每一帧挥之间隔时间需要小于1000ms/60次，大概16.6毫秒，才能让用户觉得不卡顿

5. 不需要考虑网络问题，因为这是单机游戏


### 什么是虚拟dom

1. 用js对象结构来表示dom树的结构

2. 然后用这个树构建一个真正的dom树，插到文档中

3. 当状态变更的时候，重新构造一棵新的对象数

4. 然后用新树和旧的树进行比较

5. 把记录的差异应用到所构建的真正的dom树上，视图就更新了

6. 虚拟dom的本质就是在js和dom之间做了一个缓存


### webpack是用来干什么的

1. webpack是一个现代js应用程序的静态模块打包器（module bundler）。

2. 当webpack处理应用程序的时候，他就会递归的构建一个依赖关系图

3. 其中包含应用程序所需要的每个模块，然后将这些模块打包成一个或多个bundle


### ant-design的优缺点

优点：组建非常全面，样式效果也比较不错

缺点：框架自定义程度低，默认UI风格修改困难


### 简单介绍一下Symbol

1. 是es6的新增的属性，代表给定名称作为唯一标识

2. 这样类型的值可以这样创建，`let id = symbol("id")`

3. Symbol确保唯一，即使采用相同的名称，也会产生不同的值

4. 创建的一个字段，仅为知道对应symbol的人能访问


### 箭头函数的特性

1. 箭头函数没有自己的this，需要通过作用域来确定this的值，绑定的this是指最近一层作用域的this

2. 没有自己的`arguments`对象，但是可以访问外围函数的`arguments`对象

3. 不能通过`new`关键字调用，同样也没有`new.target`值和原型


### 基本类型和引用类型的区别

1. 基本类型的值是不可变的，任何方法都无法改变一个基本类型的值，当这个变量重新赋值之后看起来是变量的值变了，但实际上这里的变量名只是指向变量的一个指针，所以改变的是指针指向的改变，该变量是不变的，但是引用类型可以改变

2. 基本类型不可以添加属性和方法，但是引用类型可以

3. 基本类型的比较是值的比较，引用类型的比较是比较内存地址是否相同

4. 基本类型是存放在栈区，引用类型同时保存在栈区和堆区


### 作用域类型

变量需要在作用域范围内才可以被使用，这个作用范围就是变量的作用域

1. 全局变量：不在任何函数内声明的变量，或者是在函数内省略var声明的变量，都成为全局变量

1. 局部变量：在函数内部显氏声明的变量

2. 块级变量：包含在`{}`之内的作用域，主要用于区分let和var声明的变量，一般是条件语句、循环语句等


### 找出数字数组中最大值的方法

1. 循环

2. 使用`Math.max()`方法

    ```js
    let arr = [1, 2, 3, 4];
    let max = Match.max(...arr);
    ```

3. sort排序取第一个或最后一个

    ```js
    arr.sort((a, b) => a - b)[arr.length - 1];
    ```


### setTimeout(callback, 100); 这个100毫秒是什么意思

1. setTimeout只是将事件插入了任务列表
2. 必须等到当前代码执行完，主线程才回去执行他指定的回调函数，有可能要等很久
3. 所以没有办法保证回调函数一定会在100毫秒的时候执行
4. 100毫秒指的是插入队列的时间+等待的时间


### 怎么获得对象上的属性

1. `for(let key in obj)`，访问一个对象原型链中所有可枚举的类型
2. `Object.keys(obj)`，返回一个数组，包含所有可枚举的属性名称


### private和public

public：表明公有，该数据成员、成员函数是对所有用户开放的，所有用户都可以直接进行调用

private：表示私有，除了class自己之外，其他用户不能直接调用


### 引用类型常见对象

Object、Array、RegExp、Date、Function

基本包装类型：String、Number、Boolean

弹体内置对象：Global、Math


### arguments

是js函数内置的一个对象，执行函数方法的实参值都存储都在arguments中

1. 像一个数组，可以使用下标来访问所有元素

2. 但是还有其他的属性，如callee

3. 也不支持数组的一些属性，如push、pop等

```js
function demo(a) {
    console.log('a', a); // 1
    console.log('arguments', arguments); // Arguments(5) [1, 2, 3, 4, 5, callee: ƒ, Symbol(Symbol.iterator): ƒ]
}
demo(1,2,3,4,5)
```

4. 箭头函数获取arguments

箭头函数是没有`arguments`的，可以使用`剩余运算符来替代`

```js
let func = (...rest) => {
  console.log(rest); // [1,2,3]
}
func(1,2,3)
```



### js事件循环机制（Event Loop）

1. 背景

    js从当诞生的时候开始，就是一门`单线程的、非阻塞的`脚本语言

    单线意味着，js代码在执行的任何时候，都只有一个主线程来处理所有的任务

    非阻塞靠的就是事件循环

2. 组成部分

    1. 主线程

        就是访问到的`script`标签里面包含的内容，或者直接访问一个js文件的时候，里面的可以在当前作用域直接执行的所有内容（方法，对象等）

    2. 宏队列（macrotask）

        setTimeout、setInterval、setImmediate、I/O、UI rendering

    3. 微队列（microtask）

        promise.then()、processCode.nextTick

    说明：js的任务队列分为同步任务和异步任务，所有的同步任务都是在主线程里执行的，异步任务可能会在宏队列或者微队列里面

3. 执行顺序

 1.  先执行主线程
 2.  遇到宏队列放到宏队列
 3.  遇到微队列放到微队列
 4.  主线程执行完毕
 5.  执行微队列，微队列执行完毕
 6.  执行一次宏队列中的一个任务
 7.  执行微队列，微队列执行完毕
 8.  依次循环


### 多维数组扁平化

1. 二维数组

    1. 扩展运算符
    2. es6的reduce方法

2. 多维数组

    1. toString().split()

        适用于：数组每一项都是简单类型

        ```js
        const arr = [[1],  [2, 3], ['hh', 'jj'], 'ii', 'mm'];
        arr.toString().split(',');
        ```

    2. 递归

        ```js
        // 进入函数，声明一个空数组arr，
        // 判断是否为数组，不是则return
        // 遍历该数组
        // 继续判断单元素是否为数组，如果是，则将元素和arr进行拼接然后递归调用自身
        // 将不是数组的元素进行push到arr中
        ```

    3. es6的flat

        不传参数时默认为一层，如果传`Infinity`则扁平化最深的

        ``js
        arr.flat()
        ```







