<!--
 * @Date: 2022-08-08 13:26:33
 * @LastEditors: Lq
 * @LastEditTime: 2022-08-09 11:05:54
 * @FilePath: \learnningNotes\面试题\前端进阶.md
-->
## 前端工程化

### Babel的原理是什么

1. babel是什么

   1. 是一个js编译器
   2. 是一个工具，能够将`es6+`的语法转换为浏览器兼容的语法（因为浏览器不兼容高版本的es语法）

      比如将箭头函数改为普通函数

2. babel的转译过程分为3个阶段

   1. 解析Parse：将代码解析成抽象语法树（AST），即词法分析和语法分析的过程

      1. 词法分析

         就是把字符串形式的代码转换为`tokens`，可以理解为一组标记数组

         ```js
         // 如 sum = 2 + 3，拆分为 操作符 数字 操作符 数字
         [
            { type: { ... }, value: "sum", start: 0, end: 2 },
            { type: { ... }, value: "=", start: 3, end: 4 },
            { type: {}, value: "2", start: 4, end: 5 },
            ...
         ]
         ```

      2. 语法分析

         进行语法检查，并构建由输入单词组成的数据结构，就是把`tokens`转换成AST抽象语法树

   2. 转换Transform：对于AST进行变换一系列的操作，babel接受得到AST并通过`babel-traverse`对其进行遍历，在此过程中添加、更新和移除等操作

   3. 生成Generate：将变换后的AST再转化为js代码，使用到的模块是`babel-generator`


### GitFlow工作流

[https://www.jianshu.com/p/7eba1f0b5b42](https://www.jianshu.com/p/7eba1f0b5b42)


### git rebase 和 git merge的区别

1. 相同点

   都是用于从一个分支获取合并到当前分支

2. 不同点

   1. merge：自动创建一个新的commit，如果合并的时候遇到冲突，仅需要修改后重新commit

      1. 优点：记录了真实的commit情况，包括每个分支的详情
      2. 缺点：因为每次merge都会自动产生一个merge commit，所以在查看commit记录时，分支很杂乱
      3. 建议场景：需要保留详细合并信息的时候使用，特别是需要将分支合并进入主分支时

   2. rebase：会合并之前的commit历史

      1. 优点：更简洁的项目历史，去掉了merge commit
      2. 缺点：如果合并出现代码问题不容易定位，因为覆盖了histroy
      3. 建议场景：如果修改某个功能频繁进行了commit提交时


### reset revert checkout的区别

1. git仓库的3个组成部分

   1. 工作区（Work Directory）：git管理下的正常目录都算是工作区，平时编辑工作都是在工作区完成
   2. 暂存区（Stage）：临时区域，里面存放的是将要提交文件的快照
   3. 历史记录区（）：commit以后的记录区

2. 几个状态转化的命令

   |      | 工作区 |                      | 暂存区 |                   | 历史记录区 |
   | ---- | ------ | -------------------- | ------ | ----------------- | ---------- |
   | 提交 |        | git add              |        | git commit        |            |
   | 撤销 |        | git checkout --files |        | git reset --files |            |


3. 共同点

   都是用来撤销代码仓库中的某些更改

4. 不同点

   1. 从commit层面来说

      1. `git reset`：将分支的末端指向之前的一个commit，然后下次git进行垃圾回收的时候，会把这个commit之后的commit都扔掉
      2. `git checkout`：可以将head移动到一个新的分支，并更新工作目录，会覆盖本地的修改
      3. `git revert`：和reset的目的是一样的，但是做法不同，它会以创建新的commit的方式来撤销commit，这样能保留之前的commit历史，比较安全

   2. 从文件层面来说

      1. `git reset`：只是把文件从历史记录区拿到暂存区，不影响工作区的内容
      2. `git checkout`：将文件从历史记录拿到工作区，不影响暂存区的内容
      3. `git revert`：不支持文件层面的操作



### webpack和gulp的区别（模块化和流的区别）

1. gulp强调的是前端开发的工作流程，我们可以通过配置一系列的task，定义task处理的事务（如文件压缩合并、雪碧图、启动server、版本控制等），然后定义顺序，让gulp执行这些task，从而构建项目的整个前端开发流程

2. webpack是一个前端模块化的方案，侧重的是模块打包，我们可以把开发中的所有资源（图片、js文件、css文件等）都看成模块，通过loader（加载器）和plugins（插件）对资源进行处理，打包成符合成产环境部署的前端资源


## Vue框架


### 对Vue的理解

1. 两大特点

   1. 响应式编程：使用Vue实现SPA（单页面应用程序），响应式编程是最核心的理念，整个系统根据数据对象对页面进行反向渲染，让站点避免结构混乱的问题

   2. 组件化：一个页面由多个不同的组件组成，当数据发生变化，最小力度更新变化的部分，不会使整个页面发生变化，从而大大提高了性能。同时每个组件都有自己独立的CSS、JS、模板


2. Vue的优势

   1. 轻量级的框架+指令

      它通过双向数据绑定把View层和Model层连接起来，实际的DOM封装和输出

   2. 双向数据绑定

      当数据发生变化的时候，视图也发生变化，当时图发生变化的时候，数据也会同步变化

   3. 组件化开发

      页面由多个不同的组件组成，每个组件依赖的CSS、JS、模板、图片等资源放在一起开发和维护

   4. 单页面路由

      把多个页面通过组件的形式集中在一个页面中，页面跳转时由Vue路由到目标页面，分别家在不同的组件，而页面不会刷新，路由在更新

   5. 虚拟dom

      Vue将模板编译成虚拟DOM渲染函数。结合Vue自带的相应系统，在状态改变时，Vue能够智能计算出重新渲染组件的最小代价，并应用到DOM操作上

   6. 渐进式框架

      用你想用或者能用的功能特性，不想用的部分功能可以先不用

   7. 数据和结构分离

      最小粒度更新，Vue每次更新都会进行虚拟dom和屏幕已有dom对比，只更新有变化的部分，性能更高

   8. 插件化

      满足大多插件可以和Vue一起配合使用

3. 缺点

   1. IE8以下不支持
   2. 社区没有Angular和React那么丰富
   3. 缺乏高阶教程和文档
   4. 因为是单页应用，不利于Seo优化
   5. 初次加载耗时多

4. 和其他框架对比

   1. Angular

      1. 相同点

         1. 都支持指令，内部指令和自定义指令
         2. 都支持过滤器，内置过滤器和自定义过滤器
         3. 都支持双向绑定

      2. 不同点

         1. Angular学习成本高，增加了依赖注入，Vue本身提供的API比较简单直观
         2. 在性能上，Angular依赖会对数据做脏检查，所以watcher越多越慢

   2. React

      1. 相同点

         1. React采用了JSX语法，Vue也可以使用特殊文件格式

         2. 都不内置Ajax、Router等功能的核心包，而是以插件的形式加载

         3. 在组件开发中都支持mixins的特性

         4. 利用虚拟dom实现快速渲染

      3. 不同点

         1. Vue在模板中提供了指令、过滤器等，非常方便可以操作DOM

         2. 渲染过程不同

         3. Vue事项了数据双向绑定，React数据流动是单向的


### 计算属性和过滤器区别

```js
<template>
  <div>
    <div>平均值1：{{ avarage1 }}</div>
    <div>平均值2：{{ avarage2 }}</div>
    <div>平均值3：{{ math | avarage3(chinese) }}</div>
  </div>
</template>

<script>
export default {
  filters: {
    avarage3: function(math, chinese) {
      return (math + chinese) / 2
    }
  },
  data() {
    return {
      math: 95,
      chinese: 86,
      avarage1: null
    }
  },
  computed: {
    avarage2: function() {
      return (this.math + this.chinese) / 2
    }
  },
  mounted() {
    this.avarage()
  },
  methods: {
    avarage: function() {
      this.avarage1 = (this.math + this.chinese) / 2
    }
  }
}
</script>
```

1. 相同点

   1. 都必须有返回值
   2. 都基于原始属性值进行变换
   3. 都可以在`{{}}`中调用

2. 不同点

   1. 计算属性

      1. 依赖于一个固定的Vue实例，需要在某一个实例中使用
      2. 不接受额外参数，依赖于data属性中的变量
      3. 有缓存管理机制，可减少页面调用次数
      4. 默认只读，可以定义为对象，开始可读可写吗欧式
      5. 被作为一个类属性调用

   2. 过滤器

      1. 依赖于实例，可以定义一个全局过滤器，在多个实例中使用
      2. 不要求是data中的变量，可以是临时变量，可以接受额外参数
      3. 无缓存机制，调用次数取决于页面中有多少个过滤器
      4. 只能读
      5. 过滤器被作为一个特殊方法处理


### Vue生命周期

1. 创建

   1. beforeCreate

      实例初始化之后，数据和事件配置之前，这个时候还不能用`this`，data中的数据，methods中的方法，watcher中的事件都无法获取

   2. created

      实例已经创建完成，这个时候已经可以操作数据和方法，不过不能对dom节点进行操作

2. 挂载

   1. beforeMount

      dom节点准备开始挂载，render相关函数首次被调用，`$el`属性已经存在，但是目前是虚拟dom，数据没有挂载到模板中

   2. mounted

      挂载完毕，dom操作可以正常进行

3. 更新：点击页面中的元素执行相应的事件

   1. beforeUpdate

      在view层的数据变化前，不是data中的数据变化前（这个时候data的数据已经更新了）

   2. updated

      view层的数据更新之后

4. 销毁：执行vm.$destroy()函数

   1. beforeDestroy

      实例销毁之前调用，这个时候`this`仍然可用，data、methods、watcher等都可以使用

   2. destroyed

      Vue实例销毁之后调用，此时Vue实例已经解除了事件监听以及dom的绑定，但是dom结构依然存在，对data的改变不会触发生命周期函数

```html
<!DOCTYPE html>
<html>
<head>
    <title></title>
</head>
<body>
<div id="app" @click="change">
    <p>{{message}}</p>
</div>
<script src="https://cdn.bootcss.com/vue/2.6.10/vue.min.js"></script>
<script type="text/javascript">
var vm = new Vue({
    el: '#app',
    data: {
        message: '今天是周一！！！'
    },
    beforeCreate(){
        console.group('beforeCreate 创建前状态==========>>');
        console.log("%c%s", "color:red", "el     : "+this.$el);   //undefined
        console.log("%c%s", "color:red", "data   : "+this.$data); //undefined
        console.log("%c%s", "color:red", "message: "+this.message);   //undefined
    },
    created(){
        console.group('created 创建完毕状态==========>>');
        console.log("%c%s", "color:red", "el     : "+this.$el);   //undefined
        console.log("%c%s", "color:red", "data   : "+this.$data); //[object Object]
        console.log("%c%s", "color:red", "message: "+this.message);   //今天是周一！！！
    },
    beforeMount(){
        console.group('beforeMount 挂载前状态==========>>');
        console.log("%c%s", "color:red", "el     : "+this.$el);   //[object HTMLDivElement]
        console.log(this.$el);
        console.log("%c%s", "color:red", "data   : "+this.$data); //[object Object]
        console.log("%c%s", "color:red", "message: "+this.message);   //今天是周一！！！
    },
    mounted(){
        console.group('mounted 挂载结束状态==========>>');
        console.log("%c%s", "color:red", "el     : "+this.$el);   //[object HTMLDivElement]
        console.log(this.$el);  
        console.log("%c%s", "color:red", "data   : "+this.$data); //[object Object]
        console.log("%c%s", "color:red", "message: "+this.message);   //今天是周一！！！
    },
    beforeUpdate(){
        console.group('beforeUpdate 更新前状态==========>>');
        console.log("%c%s", "color:red", "el     : "+this.$el);   //[object HTMLDivElement]
        console.log(this.$el);
        console.log(this.$el.innerHTML);    //<p>今天是周一！！！</p>
        console.log("%c%s", "color:red", "data   : "+this.$data); //[object Object]
        console.log("%c%s", "color:red", "message: "+this.message);   //今天周二了！！！
    },
    updated(){
        console.group('updated 更新完成状态==========>>');
        console.log("%c%s", "color:red", "el     : "+this.$el);   //[object HTMLDivElement]
        console.log(this.$el);
        console.log(this.$el.innerHTML);    //<p>今天周二了！！！</p>
        console.log("%c%s", "color:red", "data   : "+this.$data); //[object Object]
        console.log("%c%s", "color:red", "message: "+this.message);   //今天周二了！！！
    },
    beforeDestroy(){
        console.group('beforeDestroy 销毁前状态==========>>');
        console.log("%c%s", "color:red", "el     : "+this.$el);   //[object HTMLDivElement]
        console.log(this.$el);
        console.log("%c%s", "color:red", "data   : "+this.$data); //[object Object]
        console.log("%c%s", "color:red", "message: "+this.message);   //今天周二了！！！
    },
    destroyed(){
        console.group('destroyed 销毁完成状态==========>>');
        console.log("%c%s", "color:red", "el     : "+this.$el);   //[object HTMLDivElement]
        console.log(this.$el);
        console.log("%c%s", "color:red", "data   : "+this.$data); //[object Object]
        console.log("%c%s", "color:red", "message: "+this.message);   //今天周二了！！！
    },
    methods: {
        change(){
            this.message = "今天周二了！！！";
            console.group("==============点击事件执行的方法==============>>");
            console.log("%c%s", "color:red", "el     : "+this.$el);   //[object HTMLDivElement]
            console.log(this.$el);
            console.log("%c%s", "color:red", "data   : "+this.$data); //[object Object]
            console.log("%c%s", "color:red", "message: "+this.message);   //今天周二了！！！
        }
    }
})
</script>
</body>
</html>
```


### Vue如何监听键盘事件

1. 原生的js或者jQuery中，监听按下或者抬起的事件，需要判断`e.keyCode`的值来获取用户所按的键

2. Vue中已经为常用的按键设置了别名，直接使用别名就可以监听按键的事件

   ```html
   <input @keyup.enter="enterHandle">
   ```


3. 如果在自己封装的组件中，或者是使用第三方的UI库的时候，不起作用，这个时候需要使用到`.native`修饰符

   ```html
   <el-input
      v-model="inputName"
      placeholder="搜索你的文件"
      @keyup.enter.native="searchFile(params)"
   >
   </el-input>
   ```

4. 如果`.native`也无效的情况，需要使用到`$listeners`，将原生事件绑定到组件


### watch怎么深度监听对象变化

1. 使用字符串嵌套的方式

   ```js
   watch: {
      'user.address.city': function(newValue, oldValue) {

      }
   }
   ```

2. 使用深度监听方式

   deep 为true  意味着开启了深度监听 a对象里面任何数据变化都会触发handler函数

   ```js
   watch: {
      user: {
         deep: true,
         handler() {

         }
      }
   }
   ```


### 删除数组和对象用delete和Vue.delete有什么区别

1. 对于对象来说没有区别

   都是直接删除对象的属性

2. 但是删除数组的话就有区别了

   ```js
   let arr = [1, 2, 3];
   delete arr[1]; // [1, empty, 3]
   Vue.delete arr[1]; // [1, 3]
   ```

   delete是将元素变成了`empyt/undefined`，其他元素的键值不变，数组长度也不变（逻辑删除）

   Vue.delete是直接删除元素，长度发生变化（物理删除）



### watch和计算属性的区别



### Vue双向绑定原理



### v-model是什么，有什么用呢



### 在vue项目引入第三方库，怎么做


### Vue3.0为什么要用Proxy API替代defineProperty API



### Vue3.0做了哪些优化




### Vue3.0新特性 CompositionAPI和React的Hooks的异同点




### Vue3.0是如何变得更快的（底层，源码）



### Vue要做权限管理该怎么做，如果控制到按钮级别的权限该怎么做



### created和mounted中请求数据的区别是什么



### 你对proxy的理解





