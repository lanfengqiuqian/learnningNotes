<!--
 * @Date: 2022-08-04 20:34:05
 * @LastEditors: Lq
 * @LastEditTime: 2022-08-05 18:43:01
 * @FilePath: \learnningNotes\面试题\前端核心.md
-->
## 服务端编程


### 如何实现跨域

1. 什么是跨域

    js处于安全方面的考虑，不允许调用其他页面的对象

    js由于`同源策略`的限制，`a域名`下的js不能操作`b域名`下的js对象

2. 什么是同源策略

    指`协议`+`域名`+`端口`都相同，只要有一个不同，就说明两个不同源

    同源会限制一下几种行为

    1. Cookie、LocalStorage和IndexDB无法读取
    2. DOM和JS对象无法获得
    3. Ajax请求不能发送

3. 解决方案

    1. JSONP跨域

        利用`script`标签没有跨域限制，通过`script`标签的`src`属性，发送带有`callback`参数的get请求，服务端将接口返回数据拼凑到`callback`函数中，返回给浏览器，浏览器解析执行，从而前端拿到`callback`返回的数据

        原生js实现

        ```js
        var script = document.createElement('script');
        script.type = 'text/javascript';
        // 传参一个回调函数名给后端，方便后端返回时执行这个在前段定义的回调函数
        script.src = 'http://www.xxx.com:8080/login?user=xxx&callback=handleCallback';
        document.head.appendChild(script);
        // 执行回调函数
        function handleCallback(res) {
            alert(JSON.stringify(res));
        }
        ```

        服务端返回如下（返回时即执行全局函数）

        ```js
        handleCallback({"success": true, "user": "admin"});
        ```

        jqueryAjax实现

        ```js
        $.ajax({
            url: 'http://www.xxx.com:8080/login',
            type: 'get',
            dataType: 'jsonp', // 请求方式为jsonp
            jsonCallback: "handleCallback", // 自定义回调函数名
            data: {}
        })
        ```

        JSONP的缺点

        1. 只支持`get`，因为`script`标签只能使用`get`请求
        2. 需要后端配合返回指定格式的数据

        JSONP的优点

        1. 简单，兼容性好

    2. 跨域资源共享（CORS）

        允许浏览器向跨服务器发出`XMLHttpRequest`请求，从而克服了ajax只能同源使用的限制

        需要浏览器和服务器同时支持。目前所有的浏览器都支持该功能

        1. CORS跨域请求分为简单请求和非简单请求（不同的请求处理方式不一样）

            简单请求：需要同时满足下面两个条件

             1. 使用的请求方法是：`get/post/head`
             2. 请求的Header是

                1. Accept
                2. Accept-Language
                3. Content-Language
                4. Content-Type只限于3个值：`application/x-www-form-urlencoded`、`multipart/form-data`、`text/plain`

        2. 简单请求

            浏览器直接发出CORS请求，就是在头信息中增加一个`Origin`字段

            Origin字段：`http://xxx.com:8080`，说明了本地请求来自哪个源，服务器根据这个值，决定是否同意这次请求

            服务器设置的响应头字段，都以`Access-Control`开头

            1. Access-Control-Allow-Origin：必选

                要么是请求时`Origin`的指，要么是一个`*`，表示接受任意域名请求

            2. Access-Control-Allow-Credentials：可选

                表示是否允许发送Cookie，默认情况下Cookie不包括在CORS请求中，设置为true的话表示服务器允许Cookie可以包含在请求中

        3. 非简单请求

            1. 对于服务器有特殊要求的请求，比如请求方法是`PUT`、`DELETE`，或者`Content-Type`字段的类型是`application/json`

            2. 非简单请求在正式通信之前会增加以一次HTTP查询请求，称为`预检`请求（`preflight`）

                预检请求的请求方法是`OPTIONS`，用来询问服务器是否支持这个`Origin`的请求

        4. 前端设置

            ```js
            var xhr = new XMLHttpRequest();
            
            // 前端设置是否带cookie
            xhr.withCredentials = true;
            
            xhr.open('post', 'http://www.domain2.com:8080/login', true);
            xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');
            xhr.send('user=admin');
            
            xhr.onreadystatechange = function() {
                if (xhr.readyState == 4 && xhr.status == 200) {
                    alert(xhr.responseText);
                }
            ```

        5. 服务端设置

            ```js
            var http = require('http');
            var server = http.createServer();
            var qs = require('querystring');
            
            server.on('request', function(req, res) {
                var postData = '';
            
                // 数据块接收中
                req.addListener('data', function(chunk) {
                    postData += chunk;
                });
            
                // 数据接收完毕
                req.addListener('end', function() {
                    postData = qs.parse(postData);
            
                    // 跨域后台设置
                    res.writeHead(200, {
                        'Access-Control-Allow-Credentials': 'true',     // 后端允许发送Cookie
                        'Access-Control-Allow-Origin': 'http://www.domain1.com',    // 允许访问的域（协议+域名+端口）
                        /* 
                        * 此处设置的cookie还是domain2的而非domain1，因为后端也不能跨域写cookie(nginx反向代理可以实现)，
                        * 但只要domain2中写入一次cookie认证，后面的跨域接口都能从domain2中获取cookie，从而实现所有的接口都能跨域访问
                        */
                        'Set-Cookie': 'l=a123456;Path=/;Domain=www.domain2.com;HttpOnly'  // HttpOnly的作用是让js无法读取cookie
                    });
            
                    res.write(JSON.stringify(postData));
                    res.end();
                });
            });
            
            server.listen('8080');
            ```

        6. 优缺点

            1. 优点：支持所有类型的http请求，是http请求的根本解决方案
            2. 去点：对于低版本的浏览器无法兼容


    3. 通过nginx代理跨域

        实质上和`CORS`跨域原理一样，通过配置文件设置请求响应头`Access-Control-Allow-Origin`等字段

        1. nginx配置解决iconfont跨域

            浏览器跨域访问js、css、img等常规静态资源呗同源策略许可，但`iconfont`字体文件例外，此时可以在nginx的静态资源服务器中加入如下配置

            ```
            location / {
                add_header Access-Control-Allow-Origin *;
            }
            ```

        2. nginx反向代理接口跨域

            1. 前端域名为：a.com
            2. 后端域名为：b.com
            3. 现在从a向b发送请求一定会跨域
            4. 启动一个nginx服务器，将b域名改为a域名
            5. 然后设置响应的`location`以拦截前端需要跨域的请求
            6. 最后将请求代理回域名b

            ```
            server {
                listen          80;
                server_name     a.com;
                location / {
                    proxy_pass  b.com;
                }
            }
            ```

    4. 其他跨域的方案

        1. nodejs中间件代理跨域
        2. iframe跨域
        3. postMessage跨域

## Ajax

### ajax返回的状态（和http状态码不一样）

1. 0：未初始化，还没有调用`send`方法
2. 1：载入，已调用`send`方法，正在发送请求
3. 2：载入完成，`send`方法执行完成，已经接收到全部响应内容
4. 3：交互，正在解析响应内容
5. 4：完成，响应内容解析完成，可以在客户端调用了




